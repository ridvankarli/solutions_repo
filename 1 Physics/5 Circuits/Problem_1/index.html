<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Equivalent Resistance Using Graph Theory - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Equivalent Resistance Using Graph Theory";
        var mkdocs_page_input_path = "1 Physics/5 Circuits/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Investigating the Range as a Function of the Angle of Projection</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Orbital Period and Orbital Radius: Kepler's Third Law</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Escape Velocities and Cosmic Velocities</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Payload Trajectories Near Earth: Analysis and Simulation</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">5 Circuits</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Equivalent Resistance Using Graph Theory</a>
<ul class="current">
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#algorithm-implementation">Algorithm Implementation</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#series-reduction">Series Reduction</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#parallel-reduction">Parallel Reduction</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#node-elimination">Node Elimination</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#test-examples">Test Examples</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#1-simple-series-circuit">1. Simple Series Circuit</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#2-simple-parallel-circuit">2. Simple Parallel Circuit</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#3-complex-circuit">3. Complex Circuit</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#efficiency-analysis">Efficiency Analysis</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#potential-improvements">Potential Improvements</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#conclusion">Conclusion</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">5 Circuits</li>
<li class="breadcrumb-item active">Equivalent Resistance Using Graph Theory</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="equivalent-resistance-using-graph-theory">Equivalent Resistance Using Graph Theory</h1>
<h2 id="introduction">Introduction</h2>
<p>Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative, providing a structured and algorithmic way to analyze circuits.</p>
<p>By representing a circuit as a graph—where nodes correspond to junctions and edges represent resistors with weights equal to their resistance values—we can systematically simplify even the most intricate networks. This method streamlines calculations and enables automated analysis, making it particularly useful in circuit simulation software, optimization problems, and network design.</p>
<h2 id="algorithm-implementation">Algorithm Implementation</h2>
<p>The implementation uses NetworkX to represent and manipulate the circuit graph. The main algorithm iteratively simplifies the circuit graph until only the source and target nodes remain connected by a single equivalent resistor.</p>
<pre><code class="language-python">import networkx as nx
import numpy as np

class EquivalentResistanceCalculator:
    def __init__(self):
        self.graph = None
        self.simplified = False

    def load_circuit(self, graph):
        """
        Loads a circuit graph where:
        - Nodes represent junctions
        - Edges represent resistors with resistance as weights
        """
        self.graph = graph.copy()
        self.simplified = False
        return self

    def calculate_equivalent_resistance(self, source, target):
        """
        Calculate the equivalent resistance between two nodes in the circuit.

        Args:
            source: Source node
            target: Target node

        Returns:
            float: The equivalent resistance between source and target
        """
        if not self.graph:
            raise ValueError("No circuit loaded")

        if source not in self.graph or target not in self.graph:
            raise ValueError("Source or target node not in circuit")

        # Create a working copy of the graph
        working_graph = self.graph.copy()

        # Keep simplifying until we have only the source and target nodes
        while len(working_graph.nodes) &gt; 2 or len(working_graph.edges) &gt; 1:
            # Try to simplify series resistors
            series_simplified = self._simplify_series(working_graph, source, target)

            # Try to simplify parallel resistors
            parallel_simplified = self._simplify_parallel(working_graph)

            # If no simplification was possible, we need a more advanced technique
            if not (series_simplified or parallel_simplified):
                # Use Y-Δ transformation or node elimination
                self._eliminate_node(working_graph, source, target)

        # After simplification, there should be a single edge between source and target
        if len(working_graph.edges) == 1:
            edge_data = list(working_graph.edges(data=True))[0]
            return edge_data[2]['weight']
        else:
            # If there are no edges, the nodes are disconnected
            return float('inf')
</code></pre>
<h3 id="series-reduction">Series Reduction</h3>
<p>The algorithm identifies nodes with exactly two connections (degree 2) that aren't the source or target nodes. These nodes are intermediate points in series connections and can be eliminated by combining the resistances.</p>
<pre><code class="language-python">def _simplify_series(self, graph, source, target):
    """
    Identify and simplify series resistors in the circuit.
    A node with exactly two connections can be eliminated.
    """
    simplified = False

    # Find nodes that are in series (degree 2 and not source/target)
    series_nodes = [node for node in graph.nodes() 
                  if node != source and node != target and graph.degree(node) == 2]

    for node in series_nodes:
        # Get the two adjacent nodes and edge weights
        neighbors = list(graph.neighbors(node))
        if len(neighbors) != 2:
            continue

        n1, n2 = neighbors

        # Calculate the combined resistance
        r1 = graph[node][n1]['weight']
        r2 = graph[node][n2]['weight']
        combined_resistance = r1 + r2

        # Remove the middle node and add a direct edge
        graph.remove_node(node)
        graph.add_edge(n1, n2, weight=combined_resistance)

        simplified = True
        break  # We modified the graph, so break the loop

    return simplified
</code></pre>
<h3 id="parallel-reduction">Parallel Reduction</h3>
<p>The algorithm looks for multiple edges between the same pair of nodes, representing parallel resistors, and combines them according to the parallel resistance formula.</p>
<pre><code class="language-python">def _simplify_parallel(self, graph):
    """
    Identify and simplify parallel resistors in the circuit.
    Multiple edges between the same nodes are combined.
    """
    simplified = False

    # Find parallel edges
    for u in graph.nodes():
        for v in graph.nodes():
            if u &gt;= v:  # Skip repeated pairs and self-loops
                continue

            if graph.has_edge(u, v):
                # Get all parallel edges between u and v
                parallel_edges = list(graph.get_edge_data(u, v).items())

                if len(parallel_edges) &gt; 1:
                    # Calculate combined resistance (1/R = 1/R1 + 1/R2 + ...)
                    combined_conductance = sum(1/data['weight'] for _, data in parallel_edges)
                    combined_resistance = 1/combined_conductance

                    # Remove all existing edges
                    graph.remove_edge(u, v)

                    # Add new edge with combined resistance
                    graph.add_edge(u, v, weight=combined_resistance)

                    simplified = True
                    break  # We modified the graph, so break the loop

        if simplified:
            break

    return simplified
</code></pre>
<h3 id="node-elimination">Node Elimination</h3>
<p>For complex configurations where simple series or parallel reductions aren't possible, the algorithm uses node elimination. This technique eliminates a non-terminal node by creating new connections between all its neighbors, with appropriate equivalent resistances.</p>
<pre><code class="language-python">def _eliminate_node(self, graph, source, target):
    """
    Eliminate a node using the node elimination technique.
    Choose a node that's neither source nor target and eliminate it.
    """
    # Find a node to eliminate (not source or target)
    nodes_to_consider = [n for n in graph.nodes() if n != source and n != target]

    if not nodes_to_consider:
        return False

    node_to_eliminate = nodes_to_consider[0]
    neighbors = list(graph.neighbors(node_to_eliminate))

    # Process each pair of neighbors
    for i in range(len(neighbors)):
        for j in range(i+1, len(neighbors)):
            n1, n2 = neighbors[i], neighbors[j]

            # Calculate resistance between n1 and n2 through node_to_eliminate
            r1 = graph[node_to_eliminate][n1]['weight']
            r2 = graph[node_to_eliminate][n2]['weight']

            # Add new edge or update existing one
            if graph.has_edge(n1, n2):
                existing_r = graph[n1][n2]['weight']
                # Parallel combination of the new path and existing path
                new_r = 1 / (1/existing_r + 1/(r1 + r2))
                graph[n1][n2]['weight'] = new_r
            else:
                # New direct path
                graph.add_edge(n1, n2, weight=r1 + r2)

    # Remove the eliminated node
    graph.remove_node(node_to_eliminate)
    return True
</code></pre>
<h2 id="test-examples">Test Examples</h2>
<h3 id="1-simple-series-circuit">1. Simple Series Circuit</h3>
<pre><code>A -- 2Ω -- B -- 3Ω -- C
</code></pre>
<p>Expected result: 5Ω (2Ω + 3Ω)</p>
<pre><code class="language-python">def test_simple_series():
    """Test a simple series circuit."""
    circuit = create_circuit([
        ('A', 'B', 2),
        ('B', 'C', 3)
    ])
    calculator = EquivalentResistanceCalculator()
    result = calculator.load_circuit(circuit).calculate_equivalent_resistance('A', 'C')

    print(f"Simple Series Circuit: {result}Ω (Expected: 5Ω)")
    return result
</code></pre>
<h3 id="2-simple-parallel-circuit">2. Simple Parallel Circuit</h3>
<pre><code>A -- 6Ω -- B
|         |
+-- 3Ω -- +
</code></pre>
<p>Expected result: 2Ω (1/R = 1/6 + 1/3)</p>
<pre><code class="language-python">def test_simple_parallel():
    """Test a simple parallel circuit."""
    circuit = create_circuit([
        ('A', 'B', 6),
        ('A', 'B', 3)
    ])
    calculator = EquivalentResistanceCalculator()
    result = calculator.load_circuit(circuit).calculate_equivalent_resistance('A', 'B')

    print(f"Simple Parallel Circuit: {result}Ω (Expected: 2Ω)")
    return result
</code></pre>
<h3 id="3-complex-circuit">3. Complex Circuit</h3>
<pre><code>     +-- 3Ω -- B -- 1Ω --+
     |                    |
A ---+-- 2Ω -- C -- 4Ω --+--- E
     |                    |
     +-- 5Ω -- D -- 2Ω --+
</code></pre>
<p>This circuit contains both series and parallel elements, plus mesh configurations. The algorithm handles it by applying node elimination when necessary.</p>
<pre><code class="language-python">def test_complex_circuit():
    """Test a complex circuit with both series and parallel components."""
    circuit = create_circuit([
        ('A', 'B', 3),
        ('B', 'E', 1),
        ('A', 'C', 2),
        ('C', 'E', 4),
        ('A', 'D', 5),
        ('D', 'E', 2)
    ])
    calculator = EquivalentResistanceCalculator()
    result = calculator.load_circuit(circuit).calculate_equivalent_resistance('A', 'E')

    print(f"Complex Circuit: {result}Ω")
    return result
</code></pre>
<h2 id="efficiency-analysis">Efficiency Analysis</h2>
<ul>
<li><strong>Time Complexity</strong>: O(|V|³), where |V| is the number of nodes. This is dominated by the node elimination step which considers all pairs of neighbors.</li>
<li><strong>Space Complexity</strong>: O(|V|² + |E|) to store the graph representation.</li>
</ul>
<h2 id="potential-improvements">Potential Improvements</h2>
<ol>
<li>
<p><strong>Optimized Node Selection</strong>: Instead of arbitrarily picking the first available node for elimination, select nodes based on their degree or other heuristics to minimize computational effort.</p>
</li>
<li>
<p><strong>Matrix-Based Approach</strong>: For highly complex circuits, implement a more efficient matrix-based approach using modified nodal analysis or the Laplacian matrix of the graph.</p>
</li>
<li>
<p><strong>Parallelization</strong>: For very large circuits, parallelize certain operations to improve performance.</p>
</li>
<li>
<p><strong>Smart Detection of Substructures</strong>: Implement advanced pattern recognition to identify complex subcircuits that can be reduced in a single step.</p>
</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>Graph theory provides an elegant and systematic approach to calculating equivalent resistance in electrical circuits. This implementation demonstrates how series/parallel reductions combined with node elimination can handle arbitrary circuit configurations. The algorithm is robust for practical applications but can be further optimized for very large or complex networks.</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../4%20Electromagnetism/Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../6%20Statistics/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../4%20Electromagnetism/Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../6%20Statistics/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
